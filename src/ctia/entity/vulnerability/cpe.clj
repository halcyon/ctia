(ns ctia.entity.vulnerability.cpe
  "An abstraction for working with Common Platform Enumeration v2.3"
  (:require
   [clojure.string :as str]
   [version-clj.core :as v]
   [ctim.schemas.vulnerability :as vulnerability-schema]))

(def escape->internal
  "Mapping of escaped characters to internal representations to
  prevent conflicts when used within regular expressions."
  {"\\:" "_COLON_"
   "\\(" "_OPEN_PAREN_"
   "\\)" "_CLOSED_PAREN_"
   "\\+" "_PLUS_"
   "\\!" "_BANG_"
   "\\/" "_SLASH_"})

(defn ->internal
  "Replaces all escaped characters in String `s` with internal representations"
  [s]
  (reduce-kv (fn ->internal-representation-rf [acc escape internal-representation]
               (str/replace acc escape internal-representation))
             s
             escape->internal))

(defn internal->triple-escape
  "Replaces all internal representations in String `s` with their
  triple escaped forms."
  [s]
  (reduce-kv (fn internal->triple-escape-rf [acc escape internal-representation]
               (str/replace acc internal-representation (str "\\\\" escape)))
             s
             escape->internal))

(defn str->pattern
  "Converts String `s` with CPE Match String wildcards to a
  `java.util.regex.Pattern`."
  [s]
  (-> s
      (str/replace "*" ".*")
      (str/replace "?" ".?")
      re-pattern))

(defn component-match?
  "Returns true when CPE Match String components `s1` and `s2` match,
  otherwise false. When `s1` or `s2` is set to `*` or `-` returns
  true, indicating a match of `ANY` and `Not Applicable`
  respectively."
  [s1 s2]
  (let [p1 (str->pattern s1)
        p2 (str->pattern s2)]
    (or
      (= s1 s2)
      (re-matches p1 s2)
      (re-matches p2 s1))))

(defn satisfies-interval?
  "Returns true when version satisfies interval, otherwise
  false. Returns true when version is set to `*` or `-`, which
  indicate `ANY` and `Not Applicable` respectively."
  [version
   {:keys [version-start-including
           version-start-excluding
           version-end-including
           version-end-excluding]}]
  (letfn [(closed [] (and (left-closed) (right-closed)))
          (open [] (and (left-open) (right-open)))
          (left-closed-right-open [] (and (left-closed) (right-open)))
          (left-open-right-closed [] (and (left-open) (right-closed)))
          (left-closed [] (v/older-or-equal? version-start-including version))
          (left-open [] (v/older? version-start-excluding version))
          (right-closed [] (v/newer-or-equal? version-end-including version))
          (right-open [] (v/newer? version-end-excluding version))]
    (cond
      (or (= version "*") (= version "-")) true
      (and version-start-including version-end-including) (closed)
      (and version-start-excluding version-end-excluding) (open)
      (and version-start-including version-end-excluding) (left-closed-right-open)
      (and version-start-excluding version-end-including) (left-open-right-closed)
      version-start-including (left-closed)
      version-start-excluding (left-open)
      version-end-including (right-closed)
      version-end-excluding (right-open)
      :else true)))

(defprotocol ICpeMatch
  (match? [this CpeMatch])
  (required-components-specified? [this]))

(defrecord CpeMatch [part vendor product version version_update
                     edition lang sw_edition target_sw
                     target_hw other]
  Object
  (toString [_]
    (format "cpe:2.3:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s"
            part vendor product version version_update
            edition lang sw_edition target_sw
            target_hw other))

  ICpeMatch
  (match? [_ CpeMatch]
    (and (satisfies-interval? version CpeMatch)
         (and CpeMatch
              (component-match? part (:part CpeMatch))
              (component-match? vendor (:vendor CpeMatch))
              (component-match? product (:product CpeMatch))
              (component-match? version (:version CpeMatch))
              (component-match? version_update (:version_update CpeMatch))
              (component-match? edition (:edition CpeMatch))
              (component-match? lang (:lang CpeMatch))
              (component-match? sw_edition (:sw_edition CpeMatch))
              (component-match? target_sw (:target_sw CpeMatch))
              (component-match? target_hw (:target_hw CpeMatch))
              (component-match? other (:other CpeMatch)))))
  (required-components-specified? [_]
    (and (and (not= part "*") (not= part "-"))
         (and (not= vendor "*") (not= vendor "-"))
         (and (not= product "*") (not= product "-")))))

(defmethod print-method CpeMatch [v ^java.io.Writer w]
  (.write w (str v)))

(defn ->cpe-match
  "Given a Cpe Match String `s`, creates a `CpeMatch` record."
  [s]
  (apply ->CpeMatch
         (-> s
             (str/replace "\\\\" "\\")
             ->internal
             (str/replace-first "cpe:2.3:" "")
             (str/split #":"))))

(defn valid-formatted-cpe-23-string?
  "Returns true when CPE Match String `s` is a valid CPE 2.3 Match
  String and has specified required components."
  [s]
  (let [cpe-match-string (str/replace s "\\\\" "\\")]
    (if-let [CpeMatch (when (vulnerability-schema/formatted-cpe-23-string? cpe-match-string)
                        (->cpe-match cpe-match-string))]
      (required-components-specified? CpeMatch)
      false)))

(defn apply-operator
  "When value of `operator` is String `OR` or `AND`, applies
  respective boolean operator to collection `operands`. When applied
  boolean function is true returns `result`, otherwise returns nil."
  [{:keys [negate operands operator result]}]
  (let [boolean-fn (case operator
                     "OR" some
                     "AND" every?)]
    (cond-> (boolean-fn identity operands)
      negate not
      :finally (when result))))

(defn cpe_match->CpeMatch
  "Constructs a CpeMatch records from a Vulnerability Configuration tree
  leaf."
  [{:keys [versionStartIncluding
           versionStartExcluding
           versionEndIncluding
           versionEndExcluding
           cpe23Uri]}]
  (cond-> (->cpe-match cpe23Uri)
    versionStartIncluding (assoc :version-start-including versionStartIncluding)
    versionStartExcluding (assoc :version-start-excluding versionStartExcluding)
    versionEndIncluding (assoc :version-end-including versionEndIncluding)
    versionEndExcluding (assoc :version-end-excluding versionEndExcluding)))

(defn query-cpe-matches
  "Returns Vulnerabilility Configuration tree leaf `cpe_match` if
  affected by collection of CpeMatch records `cpes`, otherwise returns
  nil."
  [{:keys [cpe_match negate operator]} cpes]
  (apply-operator {:negate negate
                   :operands (for [CpeMatch (map cpe_match->CpeMatch cpe_match)]
                               (some (fn match-uri? [x] (match? x CpeMatch))
                                     cpes))
                   :operator operator
                   :result cpe_match}))

(defn query-children
  "Returns Vulnerability Configuration tree leaf `children` if
  affected by collection of CpeMatch records `cpes`, otherwise returns
  nil."
  [{:keys [children negate operator]} cpes]
  (apply-operator {:negate negate
                   :operands (map (fn query-child [child]
                                    (query-cpe-matches child cpes))
                                  children)
                   :operator operator
                   :result children}))

(defn query-node
  "Returns Vulnerability Configuration `node` if affected by collection
  of CpeMatch records `cpes`, otherwise returns nil."
  [{:keys [children cpe_match] :as node} cpes]
  (cond
    (seq cpe_match) (query-cpe-matches node cpes)
    (seq children) (query-children node cpes)))

(defn vulnerabilities->ids
  "Given a collection of CpeMatch records `cpes`, and a collection of
  `vulnerabilities`, returns a lazy sequence of ids of vulnerabilities
  with affected configurations."
  [cpes vulnerabilities]
  (letfn [(query-vulnerability
            [{{:keys [nodes]} :configurations
              id :id}]
            (when (seq (filter (fn node-matches? [node]
                                 (query-node node cpes))
                               nodes))
              id))]
    (keep query-vulnerability vulnerabilities)))
