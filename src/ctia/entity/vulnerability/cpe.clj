(ns ctia.entity.vulnerability.cpe
  (:require [clojure.string :as str]
            [version-clj.core :as v]))

(def escaped-name->literal
  {"_COLON_" "\\:"
   "_OPEN_PAREN_" "\\("
   "_CLOSED_PAREN_" "\\)"
   "_PLUS_" "\\+"
   "_BANG_" "\\!"
   "_FORWARD_SLASH_" "\\/"})

(defn ->escaped-name
  ""
  [s]
  (reduce (fn ->escaped-name-rf
            [acc [escaped-name literal]]
            (str/replace acc literal escaped-name))
          s
          escaped-name->literal))

(defn ->simple-query-string-format
  [s]
  (reduce (fn ->simple-query-string-format-rf
            [acc [escaped-name literal]]
            (str/replace acc escaped-name (str "\\\\" literal)))
          s
          escaped-name->literal))

(defn str->pattern
  [s]
  (-> s
      (str/replace "*" ".*")
      (str/replace "?" ".?")
      re-pattern))

(defn component-match?
  [s1 s2]
  (let [p1 (str->pattern s1)
        p2 (str->pattern s2)]
    (cond
      (= s1 s2) true
      (or (and (= s1 "-") (= s2 "*"))
          (and (= s1 "*") (= s2 "-"))) true
      (or (re-matches p1 s2) (re-matches p2 s1)) true
      :else false)))

(defn satisfies-interval?
  [version
   {:keys [version-start-including
           version-start-excluding
           version-end-including
           version-end-excluding]}]

  (letfn [(closed [] (and (left-closed) (right-closed)))
          (open [] (and (left-open) (right-open)))
          (left-closed-right-open [] (and (left-closed) (right-open)))
          (left-open-right-closed [] (and (left-open) (right-closed)))
          (left-closed [] (v/older-or-equal? version-start-including version))
          (left-open [] (v/older? version-start-excluding version))
          (right-closed [] (v/newer-or-equal? version-end-including version))
          (right-open [] (v/newer? version-end-excluding version))]

    (cond
      (or (= version "*") (= version "-")) true
      (and version-start-including version-end-including) (closed)
      (and version-start-excluding version-end-excluding) (open)
      (and version-start-including version-end-excluding) (left-closed-right-open)
      (and version-start-excluding version-end-including) (left-open-right-closed)
      version-start-including (left-closed)
      version-start-excluding (left-open)
      version-end-including (right-closed)
      version-end-excluding (right-open)
      :else true)))

(defprotocol ICpeMatch
  (match? [this CpeMatch]))

(defrecord CpeMatch [part vendor product version version_update
                     edition lang sw_edition target_sw
                     target_hw other]
  Object
  (toString [_]
    (format "cpe:2.3:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s"
            part vendor product version version_update
            edition lang sw_edition target_sw
            target_hw other))

  ICpeMatch
  (match? [_ CpeMatch]
    (and (satisfies-interval? version CpeMatch)
         (and CpeMatch
              (component-match? part (:part CpeMatch))
              (component-match? vendor (:vendor CpeMatch))
              (component-match? product (:product CpeMatch))
              (component-match? version (:version CpeMatch))
              (component-match? version_update (:version_update CpeMatch))
              (component-match? edition (:edition CpeMatch))
              (component-match? lang (:lang CpeMatch))
              (component-match? sw_edition (:sw_edition CpeMatch))
              (component-match? target_sw (:target_sw CpeMatch))
              (component-match? target_hw (:target_hw CpeMatch))
              (component-match? other (:other CpeMatch))))))

(defmethod print-method CpeMatch [v ^java.io.Writer w]
  (.write w (str v)))

(defn ->cpe-match
  [s]
  (apply ->CpeMatch
         (-> s
             ->escaped-name
             (str/replace-first "cpe:2.3:" "")
             (str/split #":"))))

(defn apply-operator
  [{:keys [negate operands operator result]}]
  (case operator
    "OR" (when (if negate
                 (not (some identity operands))
                 (some identity operands))
           result)
    "AND" (when (if negate
                  (not (every? identity operands))
                  (every? identity operands))
            result)))

(defn cpe_match->CpeMatch
  [{:keys [versionStartIncluding
           versionStartExcluding
           versionEndIncluding
           versionEndExcluding
           cpe23Uri]}]
  (cond-> (->cpe-match cpe23Uri)
    versionStartIncluding (assoc :version-start-including versionStartIncluding)
    versionStartExcluding (assoc :version-start-excluding versionStartExcluding)
    versionEndIncluding (assoc :version-end-including versionEndIncluding)
    versionEndExcluding (assoc :version-end-excluding versionEndExcluding)))

(defn query-cpe-matches
  [{:keys [cpe_match negate operator]} cpes]
  (apply-operator {:negate negate
                   :operands (for [CpeMatch (map cpe_match->CpeMatch cpe_match)]
                               (some (fn match-uri? [x] (match? x CpeMatch))
                                     cpes))
                   :operator operator
                   :result cpe_match}))

(defn query-children
  [{:keys [children negate operator]} cpes]
  (apply-operator {:negate negate
                   :operands (map (fn query-child [child]
                                    (query-cpe-matches child cpes))
                                  children)
                   :operator operator
                   :result children}))

(defn query-node
  [{:keys [children cpe_match] :as node} cpes]
  (cond
    (seq cpe_match) (query-cpe-matches node cpes)
    (seq children) (query-children node cpes)))

(defn vulnerabilities->ids
  [cpes vulnerabilities]
  (letfn [(query-vulnerability
            [{{:keys [nodes]} :configurations
              id :id}]
            (when (seq (filter (fn [node]
                                 (query-node node cpes))
                               nodes))
              id))]
    (keep query-vulnerability vulnerabilities)))
