(ns ctia.entity.vulnerability.cpe
  "An abstraction for working with Common Platform Enumeration v2.3"
  (:require
   [clojure.string :as str]
   [version-clj.core :as v]
   [ctim.schemas.vulnerability :as vulnerability-schema]
   [schema.core :as s]))

(defn component-specified?
  [component]
  (and (not= component "*")
       (not= component "-")))

(s/defschema CpeMatch
  {:part (s/enum "a" "h" "o")
   :vendor (s/pred component-specified?)
   :product (s/pred component-specified?)
   :version s/Str
   :version_update s/Str
   :edition s/Str
   :lang s/Str
   :sw_edition s/Str
   :target_sw s/Str
   :target_hw s/Str
   :other s/Str})

(def escape->internal
  "Mapping of escaped characters to internal representations to
  prevent conflicts when used within regular expressions."
  {"\\:" "_COLON_"
   "\\(" "_OPEN_PAREN_"
   "\\)" "_CLOSED_PAREN_"
   "\\+" "_PLUS_"
   "\\!" "_BANG_"
   "\\/" "_SLASH_"})

(defn ->internal
  "Replaces all escaped characters in String `s` with internal representations"
  [s]
  (reduce-kv (fn ->internal-representation-rf [acc escape internal-representation]
               (str/replace acc escape internal-representation))
             s
             escape->internal))

(defn internal->triple-escape
  "Replaces all internal representations in String `s` with their
  triple escaped forms."
  [s]
  (reduce-kv (fn internal->triple-escape-rf [acc escape internal-representation]
               (str/replace acc internal-representation (str "\\\\" escape)))
             s
             escape->internal))

(defn str->pattern
  "Converts String `s` with CPE Match String wildcards to a
  `java.util.regex.Pattern`."
  [s]
  (-> s
      (str/replace "*" ".*")
      (str/replace "?" ".?")
      re-pattern))

(defn component-match?
  "Returns true when CPE Match String components `s1` and `s2` match,
  otherwise false. When `s1` or `s2` is set to `*` or `-` returns
  true, indicating a match of `ANY` and `Not Applicable`
  respectively."
  [s1 s2]
  (let [p1 (str->pattern s1)
        p2 (str->pattern s2)]
    (or
      (= s1 s2)
      (re-matches p1 s2)
      (re-matches p2 s1))))

(defn satisfies-interval?
  "Returns true when version satisfies interval, otherwise
  false. Returns true when version is set to `*` or `-`, which
  indicate `ANY` and `Not Applicable` respectively."
  [version
   {:keys [version-start-including
           version-start-excluding
           version-end-including
           version-end-excluding]}]
  (letfn [(closed [] (and (left-closed) (right-closed)))
          (open [] (and (left-open) (right-open)))
          (left-closed-right-open [] (and (left-closed) (right-open)))
          (left-open-right-closed [] (and (left-open) (right-closed)))
          (left-closed [] (v/older-or-equal? version-start-including version))
          (left-open [] (v/older? version-start-excluding version))
          (right-closed [] (v/newer-or-equal? version-end-including version))
          (right-open [] (v/newer? version-end-excluding version))]
    (cond
      (or (= version "*") (= version "-")) true
      (and version-start-including version-end-including) (closed)
      (and version-start-excluding version-end-excluding) (open)
      (and version-start-including version-end-excluding) (left-closed-right-open)
      (and version-start-excluding version-end-including) (left-open-right-closed)
      version-start-including (left-closed)
      version-start-excluding (left-open)
      version-end-including (right-closed)
      version-end-excluding (right-open)
      :else true)))

(defn match?
  [{:keys [part vendor product version version_update
           edition lang sw_edition target_sw
           target_hw other]}
   cpe-match]
  (and (satisfies-interval? version cpe-match)
       (and cpe-match
            (component-match? part (:part cpe-match))
            (component-match? vendor (:vendor cpe-match))
            (component-match? product (:product cpe-match))
            (component-match? version (:version cpe-match))
            (component-match? version_update (:version_update cpe-match))
            (component-match? edition (:edition cpe-match))
            (component-match? lang (:lang cpe-match))
            (component-match? sw_edition (:sw_edition cpe-match))
            (component-match? target_sw (:target_sw cpe-match))
            (component-match? target_hw (:target_hw cpe-match))
            (component-match? other (:other cpe-match)))))

(defn ->cpe-match
  "Given a Cpe Match String `s`, creates a `CpeMatch` map."
  [s]
  (let [components (-> s
                       (str/replace "\\\\" "\\")
                       ->internal
                       (str/replace-first "cpe:2.3:" "")
                       (str/split #":"))]
    {:part (nth components 0)
     :vendor (nth components 1)
     :product (nth components 2)
     :version (nth components 3)
     :version_update (nth components 4)
     :edition (nth components 5)
     :lang (nth components 6)
     :sw_edition (nth components 7)
     :target_sw (nth components 8)
     :target_hw (nth components 9)
     :other (nth components 10)}))

(defn valid-formatted-cpe-23-string?
  "Returns true when CPE Match String `s` is a valid CPE 2.3 Match
  String and has specified required components."
  [s]
  (let [cpe-match-string (str/replace s "\\\\" "\\")]
    (if-let [cpe-match (when (vulnerability-schema/formatted-cpe-23-string? cpe-match-string)
                         (->cpe-match cpe-match-string))]
      (and (component-specified? (:part cpe-match))
           (component-specified? (:vendor cpe-match))
           (component-specified? (:product cpe-match)))
      false)))

(defn apply-operator
  "When value of `operator` is String `OR` or `AND`, applies
  respective boolean operator to collection `operands`. When applied
  boolean function is true returns `result`, otherwise returns nil."
  [{:keys [negate operands operator result]}]
  (let [boolean-fn (case operator
                     "OR" some
                     "AND" every?)]
    (cond-> (boolean-fn identity operands)
      negate not
      :finally (when result))))

(defn cpe_match->CpeMatch
  "Constructs a CpeMatch records from a Vulnerability Configuration tree
  leaf."
  [{:keys [versionStartIncluding
           versionStartExcluding
           versionEndIncluding
           versionEndExcluding
           cpe23Uri]}]
  (cond-> (->cpe-match cpe23Uri)
    versionStartIncluding (assoc :version-start-including versionStartIncluding)
    versionStartExcluding (assoc :version-start-excluding versionStartExcluding)
    versionEndIncluding (assoc :version-end-including versionEndIncluding)
    versionEndExcluding (assoc :version-end-excluding versionEndExcluding)))

(defn query-cpe-matches
  "Returns Vulnerabilility Configuration tree leaf `cpe_match` if
  affected by collection of CpeMatch records `cpes`, otherwise returns
  nil."
  [{:keys [cpe_match negate operator]} cpes]
  (apply-operator {:negate negate
                   :operands (for [CpeMatch (map cpe_match->CpeMatch cpe_match)]
                               (some (fn match-uri? [x] (match? x CpeMatch))
                                     cpes))
                   :operator operator
                   :result cpe_match}))

(defn query-children
  "Returns Vulnerability Configuration tree leaf `children` if
  affected by collection of CpeMatch records `cpes`, otherwise returns
  nil."
  [{:keys [children negate operator]} cpes]
  (apply-operator {:negate negate
                   :operands (map (fn query-child [child]
                                    (query-cpe-matches child cpes))
                                  children)
                   :operator operator
                   :result children}))

(defn query-node
  "Returns Vulnerability Configuration `node` if affected by collection
  of CpeMatch records `cpes`, otherwise returns nil."
  [{:keys [children cpe_match] :as node} cpes]
  (cond
    (seq cpe_match) (query-cpe-matches node cpes)
    (seq children) (query-children node cpes)))

(defn vulnerabilities->ids
  "Given a collection of CpeMatch records `cpes`, and a collection of
  `vulnerabilities`, returns a lazy sequence of ids of vulnerabilities
  with affected configurations."
  [cpes vulnerabilities]
  (letfn [(query-vulnerability
            [{{:keys [nodes]} :configurations
              id :id}]
            (when (seq (filter (fn node-matches? [node]
                                 (query-node node cpes))
                               nodes))
              id))]
    (keep query-vulnerability vulnerabilities)))
